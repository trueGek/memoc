%% This is file `elsarticle-template-1-num.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%%
%% $Id: elsarticle-template-1-num.tex 149 2009-10-08 05:01:15Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-1-num.tex $
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
\usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}


\usepackage[italian]{babel}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{listings}
\lstloadlanguages{C++}

\renewcommand{\lstlistingname}{Codice}

\journal{Journal Name}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Corso di Metodi e Modelli per l'Ottimizzazione Combinatoria - Relazione progetto}


\address{Universit\'a degli studi di Padova \\ Anno Accademico 2015/2016}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author{\textbf{Studente:} Giacomo Quadrio \\\textbf{Matricola:} 1061566}
\end{frontmatter}

%%\begin{abstract}

\textbf{\abstractname{}}

%% Text of abstract
Il progetto del corso di Metodi e Modelli per l'Ottimizzazione Combinatoria consiste nel risolvere un problema che vede coinvolta un'azienda metalmeccanica che produce pannelli forati per la costruzione di quadri elettrici. La foratura di questi è eseguita attraverso un macchinario a controllo numerico dotato di una punta diamantata che, muovendosi sul pannello secondo una sequenza programmata, produce i fori nelle posizioni desiderate. L'obiettivo è quindi quello di individuare la sequenza di foratura ottimale che minimizzi i tempi di produzione, tenendo conto che il tempo necessario per la foratura è lo stesso e costante per tutti i punti.


%%
%% Start line numbering here if you want
%%
%%\linenumbers

%% main text
\section{Modello del problema}
\label{S:1}
Il problema oggetto del progetto pu\'o essere formulato come un problema di ottimizzazione su reti di flusso partendo quindi da un grafo G = (N,A). Scegliendo arbitrariamente un nodo di partenza 0 $\in$ N impostiamo ad $\mid$N$\mid$ il flusso uscente da esso in modo tale che venga spinto verso altri nodi. Tale operazione ha per\'o dei vincoli ovvero ciascun nodo, eccetto l'origine, ricever\'a una e una sola unit\'a di flusso, ogni nodo sia visitato una e una sola volta e che il costo del cammino, in termini di pesi c{\tiny ij}, sia minimo.

\subsection{Il modello nella Programmazione Lineare Intera}

Il problema può essere formalizzato con il seguente modello di programmazione lineare intera. Avremo quindi:
\\

\begin{large}
\textbf{Insiemi}
\end{large}

\begin{itemize}
\item \textbf{N:} nodi del grafo, rappresentano le posizioni dei fori da realizzare
\item \textbf{A:} insieme degli archi (i,j) con i e j $\in$ N. Essi rappresentano il tragitto per spostarsi dal nodo i al nodo j\\

\end{itemize}

\begin{large}
\textbf{Parametri}
\end{large}

\begin{itemize}
\item \textbf{c{\tiny ij}:} tempo impiegato per spostarsi dal nodo i al nodo j con i e j $\in$ N e l'arco (i,j) $\in$ A.
\item \textbf{0:} nodo di partenza del cammino $\in$ N.\\

\end{itemize}


\begin{large}
\textbf{Variabili decisionali}
\end{large}

\begin{itemize}
\item \textbf{x{\tiny ij}:} unità di flusso trasportate da i a j con i e j  $\in$ N e l'arco (i,j) $\in$ A.
\item \textbf{y{\tiny ij}:} indica l'utilizzo dell'arco (i,j), 1 se viene utilizzato, 0 altrimenti. Avremo che i e j  $\in$ N e l'arco (i,j) $\in$ A.\\

\end{itemize}

\begin{large}
\textbf{Vincoli\\}
\end{large}

Il modello, a questo punto, prevede un totale di cinque vincoli differenti che possono essere indicati come segue:


\begin{enumerate}
\item Il flusso uscente da x{\tiny 0j} deve essere massimo, cioè $\mid$N$\mid$
\item Ogni nodo utilizza al massimo una unità di flusso, tranne il nodo di partenza
\item Ogni nodo ha un solo arco in entrata
\item Ogni nodo ha un solo arco in uscita
\item Se vi è un'unità di flusso trasportata da i a j deve di conseguenza esserci un arco che va da i a j\\
\end{enumerate}

\begin{large}
\textbf{Modello\\}
\end{large}
**Inserire formule varie**

\section{Metaeuristiche scelte per il modello e loro implementazione}
\label{S:2}

Il progetto da svolgere richiesto dal corso di Metodi e Modelli per l'Ottimizzazione Combinatoria prevede l'implementazione del modello di programmazione lineare intera tramite due tecniche ovvero CPLEX ed una o più metaeuristiche a nostra scelta. Una volta fatto ciò si procederà testando i metodi con delle istanze di prova ed i risultati e statistiche confrontati tra di loro per valutarne le prestazioni.

Nello specifico, il problema in esame è un problema di ricerca di vicinato e consiste nel definire una soluzione iniziale e cercare di migliorarla esplorando un intorno di questa soluzione; quindi i metodi utilizzati all'interno del progetto sono due, la Local Search ed il Simulated Annealing, i cui algoritmi sono riportati qui di seguito:


\begin{lstlisting}[basicstyle=\small, caption={Local Search}, frame=single, language=C++]

sol = getInitialSol(random);

while (true){
	vector<int> newSol = findBestN(sol);
	if (evaluate(newSol) >= evaluate(sol)){	
		return evaluate(sol);
	}else{					
		sol = newSol;
	}
}


\end{lstlisting}


Come si può vedere, l'algoritmo di Local Search crea innanzitutto una soluzione iniziale da cui partire tramite la funzione getInitialSol, dopodiché esso è stato implementato utilizzando un unico ciclo while che opera finché non viene restituito in output un valore. Questo significa che ciò avverrà unicamente quando, dopo aver calcolato un una nuova soluzione con newSol = findBestN(sol), il suo valore sarà peggiore del valore della soluzione corrente. Se così non è la soluzione corrente viene aggiornata alla soluzione appena calcolata ed il ciclo continua ad operare fino al punto in cui viene trovata una soluzione peggiorativa. 


\begin{lstlisting}[basicstyle=\small, caption={Simulated Annealing}, frame=single, language=C++]

sol = getInitialSol(random);
n_passi = 100000.0 * n / 5;

while (step < n_passi){
	newSol = getNeigh(sol,2,true);			
	float de = evaluate(sol) - evaluate(newSol);
	if (de > 0){
		sol = newSol;
	}else{ 
		temp = 1-(step/n_passi);	
		double prob = exp((de)/temp);	
		srand(time(NULL)+for_random);		
		for_random = for_random + 1;
		
		if (prob*100 > (rand()%100) ){
			sol = newSol;
		}
	}
step ++; 
}

return(LocalSearch(sol));
	
\end{lstlisting}

Per quanto concerne invece l'algoritmo di Simulated Annealing, anch'esso crea innanzitutto una soluzione iniziale da cui partire tramite la funzione getInitialSol, dopodiché troviamo un ciclo while principale che opererà finché step <= n-passi; da notare che il numero di passi inoltre è dinamico così che cresca al crescere del numero di nodi coinvolti nel problema. In cosa consiste quindi questo algoritmo? In sostanza viene calcolata una nuova soluzione attraverso la funzione getNeigh, dopodiché verrà calcolata la differenza tra il valore della soluzione corrente e quello della nuova soluzione. Se il delta ottenuto è maggiore di zero significa che la nuova soluzione è migliorativa e quindi aggiornerò di conseguenza sol, se invece così non è procederemo in maniera differente rispetto alla Local Search. Andremo infatti a calcolare per prima cosa la temperatura di raffreddamento, valore che è coinvolto nel calcolo della probabilità di accettare una mossa peggiorativa. Questa probabilità è calcolata come segue:

\begin{center}
prob = exp( $\delta$/t)
\end{center}

dove $\delta$ è l'entità del peggioramento de e t è la temperatura temp di raffreddamento. Nel caso la probabilità prob sia maggiore di un numero random calcolato attraverso la funzione srand ciò comporterà appunto l'accettare la mossa peggiorativa, altrimenti essa verrà scartata. Come si modifica però la probabilità p? Essa diminuisce al crescere del peggioramento indotto dalla mossa stessa e cresce al crescere della temperatura t di processo.

Al termine delle operazioni eseguite tramite il ciclo while andremo ad effettuare infine una fase di intensificazione tramite l'operazione di Local Search eseguita sulla soluzione migliore calcolata in precedenza. Il motivo di ciò è che la Local Search è una tecnica relativamente economica in quanto a tempi di esecuzione e permette di raffinare ulteriormente la soluzione trovata.


\begin{figure}[h]
\centering\includegraphics[width=0.4\linewidth]{placeholder}
\caption{Figure caption}
\end{figure}



\begin{equation}
\label{eq:emc}
e = mc^2
\end{equation}

\section{Descrizione dei test effettuati}
\label{S:3}

Per verificare le prestazioni degli algoritmi utilizzati nel progetto sono stati condotti diversi test con un numero ben definito di istanze per differenti tipologie di dataset. Nel dettaglio sono stati utilizzati quattro diversi dataset in cui i punti sono disposti come segue:

\begin{itemize}
\item \textbf{Distribuzione uniforme} ovvero uniformemente disposti all'interno dello spazio
\item In \textbf{cluster} e disposti in tre raggruppamenti
\item In \textbf{circoli} e disposti in tre circonferenze
\item In \textbf{linea} e disposti in tre fasce \\
\end{itemize}
Per ciascuna tipologia di dataset sono stati poi selezionati 10 raggruppamenti composti da 4 istanze, ognuno con un numero di nodi che va da 10 a 100 ed in cui la differenza della quantità di elementi tra un gruppo ed il successivo è pari a 10. 

I test condotti per i vari algoritmi sono stati effettuati utilizzando, di volta in volta, sempre gli stessi dataset così da poter confrontare meglio i risultati. Ogni istanza di ogni raggruppamento di ogni dataset è stata infine data in pasto agli algoritmi per un totale di 10 volte ed i risultati registrati ritenuti interessanti per la valutazione sono stati quindi i seguenti:\\

\textbf{{\large Esecuzione utilizzando CPLEX:}
}\begin{itemize}
\item Tempo medio impiegato per le 10 esecuzioni di ogni istanza
\item Valore dell'ottimo\\
\end{itemize}


\textbf{{\large Esecuzione utilizzando la Local Search}
}\begin{itemize}
\item Tempo medio impiegato per le 10 esecuzioni di ogni istanza
\item Tempo totale impiegato dalle 10 esecuzioni
\item Miglior soluzione ottenuta con la sola Local Search
\item Peggior soluzione ottenuta con la sola Local Search
\item Media delle soluzioni ottenute con la sola Local Search
\item Varianza ottenuna
\end{itemize}

\textbf{
{\large Esecuzione utilizzando il Simulated Annealing:}}
\begin{itemize}
\item Tempo medio impiegato per le 10 esecuzioni di ogni istanza
\item Tempo totale impiegato dalle 10 esecuzioni
\item Miglior soluzione ottenuta con il Simulated Annealing
\item Peggior soluzione ottenuta con il Simulated Annealing
\item Media delle soluzioni ottenute con il Simulated Annealing
\item Varianza ottenuna
\item Miglior soluzione ottenuta con l'esecuzione della Local Search sui risultati del Simulated Annealing
\item Peggior soluzione ottenuta con l'esecuzione della Local Search sui risultati del Simulated Annealing
\item Media delle soluzioni ottenute con l'esecuzione della Local Search sui risultati del Simulated Annealing
\item Varianza ottenuna\\

\end{itemize}


\section{Descrizione dei risultati ottenuti}
\label{S:4}



%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%% Usage of \cite is as follows:
%%   \cite{key}          ==>>  [#]
%%   \cite[chap. 2]{key} ==>>  [#, chap. 2]
%%   \citet{key}         ==>>  Author [#]

%% References with bibTeX database:

\bibliographystyle{model1-num-names}
\bibliography{sample.bib}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model1-num-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have the following form:
%%   \bibitem{key}...
%%

% \bibitem{}

% \end{thebibliography}


\end{document}

%%
%% End of file `elsarticle-template-1-num.tex'.
